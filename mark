#!/bin/bash

#TODO: somehow remove extra zip but leave the most recent ones

#TODO: make marking app, integrated with output.txt

# $1 zip folder
# $2 dest folder (assignment #)
unzip_all(){
echo $#
if [ "$#" -ne 2 ]; then
  echo "error: unzip must take 2 parameters"
else
  unzip "$1" -d $2
  cd $2
  files=(*)
  # echo "${files[@]}"
  for i in "${!files[@]}"; do
    echo ${files[i]}
    new_dir=$(parse_folder_name "${files[i]}" "a1")
    if [ "$new_dir" != "" ]; then
      mkdir $new_dir
      unzip "${files[i]}" -d $new_dir
      rm "${files[i]}"
    fi
  done
  cd ..
  rm "$1"
fi
}

# get folder_name from a long list of name
# $1 is for folder name
# $2 is assignment name
parse_folder_name(){
  if [ "$#" -ne 2 ]; then
    # return would not be correct
    # echo "error: parse_folder_name requires folder name"
    echo ""
    return 0
  elif [ "${1: -4}" != ".zip" ]; then
    echo ""
    return 0
  else
    name="$2"
    for w in $1
    do
      # echo $w
      if [[ "$w" = "-" && "$start" = true ]]; then
        break
      fi
      if [ "$start" = true ]; then
        name=$(echo ${name}_${w})
      fi
      if [ "$w" = "-" ]; then
        start=true
      fi
    done
    echo $name
  fi
}

# assume already have the folders unzipped
# validate all the files under appropriate folders
# also clean up the output
validate(){
  output_filename="output.txt"
  cd $1
  if [ -f $output_filename ]; then
    rm $output_filename
  fi
  files=(*)
  for i in "${!files[@]}"; do
    new_dir=${files[i]}
    if [[ -d $new_dir ]]; then
      cd "$new_dir"
      inner_files=(*)
      for j in "${!inner_files[@]}"; do
        if [[ "${inner_files[j]}" =~ __.* ]]; then
          echo "skipping directory $new_dir/${inner_files[j]}"
        else
          echo "checking dir: $new_dir/${inner_files[j]}" >> ../$output_filename
          java -jar ../../vnu.jar_18.8.29/dist/vnu.jar --skip-non-html ${inner_files[j]} >> ../$output_filename 2>&1
          java -jar ../../vnu.jar_18.8.29/dist/vnu.jar --skip-non-css ${inner_files[j]} >> ../$output_filename 2>&1
          echo -e "\n" >> ../$output_filename
        fi
      done
      cd ..
    else
      echo "$new_dir is not directory...skipping..."
    fi
  done
  # clean up
  output_cleanup $output_filename $2
}

# clean up the output file to remove all the path that reveals my computer's path structure
output_cleanup() {
  file="$1"
  folder="$2"
  if [ "$file" == "" ]; then
    echo "-c must have src" >&2
    exit 1
  fi
  echo "going to clean up "
  sed -i 's/file.*'$folder'/file:\/'$folder'/g' $file
  echo "clean up done"
}

# print usage
print_usage(){
  echo -e "usage: $0 [-u src folder] [-v src dst] [-i file_name]
    \n\t-i: validate individual HTML with file_name and produce tmp.txt
    \n\t-v: validate HTMLs under src folder and produce output.txt, only display path from folder onwards
    \n\t-u: unzip all .zip folders in src to specific named folders in dst
    \n\t-c: clean-up output.txt
    \nnote: can only run 1 flag at same time; ignores extra parameters"
}

# mark individual files with regex as file names
# $1 file name
# saves to tmp.txt
validate_individual(){
  file_name="$1"
  if [ "$file_name" == "" ]; then
    echo "-i must have file_name; can be regex" >&2
    exit 1
  fi
  java -jar vnu.jar_18.8.29/dist/vnu.jar --html "$file_name" > tmp.txt 2>&1
  output_cleanup tmp.txt
}

# fname="70537-67796 - Michael Yee - Sep 11, 2018 423 PM - a1_Michael_Yee.zip.zip
# "
# parse_folder_name "$fname" "a1"

# using flags
# -v src: validate HTMLs under this folder and produce a output.txt with all results
# -u src
# adapted from https://stackoverflow.com/questions/18414054/bash-getopts-reading-optarg-for-optional-flags
if [[ "$1" =~ ^((-{1,2})([Hh]$|[Hh][Ee][Ll][Pp])|)$ ]]; then
  print_usage;
  exit 1
else
  # while [[ $# -gt 0 ]]; do
    opt="$1"
    shift;
    case "$opt" in
      "-u")
        src="$1";
        dst="$2";
        echo $src $dst
        if [[ "$src" == "" || "$dst" == "" ]]; then
          echo "-u must have src and dst" >&2
          exit 1
        fi
        unzip_all "$src" "$dst"
        echo "inside u $src $dst"
        ;;
      "-v")
        echo "inside v"
        src="$1";
        folder="$2";
        validate $src $folder
        ;;
      "-i")
        echo "inside i"
        f="$1";
        validate_individual "$1"
        ;;
      "-c")
        echo "clean up"
        output_cleanup "$1" "$2"
        ;;
      *)
        echo "ERROR: Invalid option: \""$opt"\"" >&2
        exit 1
        ;;
    esac
  # done
fi
